// Generated by `wit-bindgen` 0.7.0. DO NOT EDIT!

/// Declares the export of the component's world for the
/// given type.
#[macro_export]
macro_rules! export_messaging(($t:ident) => {
  const _: () = {
    
    #[doc(hidden)]
    #[export_name = "wasi:messaging/messaging-guest#configure"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __export_configure() -> i32 {
      exports::wasi::messaging::messaging_guest::call_configure::<$t>()
    }
    
    #[doc(hidden)]
    #[export_name = "cabi_post_wasi:messaging/messaging-guest#configure"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_configure(arg0: i32,) {
      exports::wasi::messaging::messaging_guest::post_return_configure::<$t>(arg0,)
    }
    
    #[doc(hidden)]
    #[export_name = "wasi:messaging/messaging-guest#handler"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __export_handler(arg0: i32,arg1: i32,) -> i32 {
      exports::wasi::messaging::messaging_guest::call_handler::<$t>(arg0,arg1,)
    }
    
  };
  
  #[used]
  #[doc(hidden)]
  #[cfg(target_arch = "wasm32")]
  static __FORCE_SECTION_REF: fn() = __link_section;
});
pub mod wasi {
  pub mod messaging {
    
    #[allow(clippy::all)]
    pub mod messaging_types {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      
      /// Format specification for messages
      /// - more info: https://github.com/clemensv/spec/blob/registry-extensions/registry/spec.md#message-formats
      /// - message metadata can further decorate w/ things like format version, and so on.
      #[repr(u8)]
      #[derive(Clone, Copy, PartialEq, Eq)]
      pub enum FormatSpec {
        Cloudevents,
        Http,
        Amqp,
        Mqtt,
        Kafka,
        Raw,
      }
      impl ::core::fmt::Debug for FormatSpec {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            FormatSpec::Cloudevents => {
              f.debug_tuple("FormatSpec::Cloudevents").finish()
            }
            FormatSpec::Http => {
              f.debug_tuple("FormatSpec::Http").finish()
            }
            FormatSpec::Amqp => {
              f.debug_tuple("FormatSpec::Amqp").finish()
            }
            FormatSpec::Mqtt => {
              f.debug_tuple("FormatSpec::Mqtt").finish()
            }
            FormatSpec::Kafka => {
              f.debug_tuple("FormatSpec::Kafka").finish()
            }
            FormatSpec::Raw => {
              f.debug_tuple("FormatSpec::Raw").finish()
            }
          }
        }
      }
      /// A message with a binary payload, a format specification, and decorative metadata.
      #[derive(Clone)]
      pub struct Message {
        pub data: wit_bindgen::rt::vec::Vec::<u8>,
        pub format: FormatSpec,
        pub metadata: Option<wit_bindgen::rt::vec::Vec::<(wit_bindgen::rt::string::String,wit_bindgen::rt::string::String,)>>,
      }
      impl ::core::fmt::Debug for Message {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Message").field("data", &self.data).field("format", &self.format).field("metadata", &self.metadata).finish()
        }
      }
      /// TODO(danbugs): This should be eventually extracted as an underlying type for other wasi-cloud-core interfaces.
      pub type Error = u32;
      /// A connection to a message-exchange service (e.g., buffer, broker, etc.).
      pub type Client = u32;
      /// There are two types of channels:
      /// - publish-subscribe channel, which is a broadcast channel, and
      /// - point-to-point channel, which is a unicast channel.
      /// 
      /// The interface doesn't highlight this difference in the type itself as that's uniquely a consumer issue.
      pub type Channel = wit_bindgen::rt::string::String;
      /// Configuration includes a required list of channels the guest is subscribing to, and an optional list of extensions key-value pairs
      /// (e.g., partitions/offsets to read from in Kafka/EventHubs, QoS etc.).
      #[derive(Clone)]
      pub struct GuestConfiguration {
        pub channels: wit_bindgen::rt::vec::Vec::<Channel>,
        pub extensions: Option<wit_bindgen::rt::vec::Vec::<(wit_bindgen::rt::string::String,wit_bindgen::rt::string::String,)>>,
      }
      impl ::core::fmt::Debug for GuestConfiguration {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GuestConfiguration").field("channels", &self.channels).field("extensions", &self.extensions).finish()
        }
      }
      #[allow(clippy::all)]
      pub fn disconnect(c: Client,){
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[link(wasm_import_module = "wasi:messaging/messaging-types")]
          extern "C" {
            #[cfg_attr(target_arch = "wasm32", link_name = "disconnect")]
            #[cfg_attr(not(target_arch = "wasm32"), link_name = "wasi:messaging/messaging-types_disconnect")]
            fn wit_import(
            _: i32, );
          }
          wit_import(wit_bindgen::rt::as_i32(c));
        }
      }
      #[allow(clippy::all)]
      pub fn connect(name: &str,) -> Result<Client,Error>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 8]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = name;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let ptr1 = ret_area.as_mut_ptr() as i32;
          #[link(wasm_import_module = "wasi:messaging/messaging-types")]
          extern "C" {
            #[cfg_attr(target_arch = "wasm32", link_name = "connect")]
            #[cfg_attr(not(target_arch = "wasm32"), link_name = "wasi:messaging/messaging-types_connect")]
            fn wit_import(
            _: i32, _: i32, _: i32, );
          }
          wit_import(ptr0, len0, ptr1);
          match i32::from(*((ptr1 + 0) as *const u8)) {
            0 => Ok(*((ptr1 + 4) as *const i32) as u32),
            1 => Err(*((ptr1 + 4) as *const i32) as u32),
            #[cfg(not(debug_assertions))]
            _ => ::core::hint::unreachable_unchecked(),
            #[cfg(debug_assertions)]
            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      #[allow(clippy::all)]
      pub fn drop_error(e: Error,){
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[link(wasm_import_module = "wasi:messaging/messaging-types")]
          extern "C" {
            #[cfg_attr(target_arch = "wasm32", link_name = "drop-error")]
            #[cfg_attr(not(target_arch = "wasm32"), link_name = "wasi:messaging/messaging-types_drop-error")]
            fn wit_import(
            _: i32, );
          }
          wit_import(wit_bindgen::rt::as_i32(e));
        }
      }
      #[allow(clippy::all)]
      pub fn trace(e: Error,) -> wit_bindgen::rt::string::String{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 8]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let ptr0 = ret_area.as_mut_ptr() as i32;
          #[link(wasm_import_module = "wasi:messaging/messaging-types")]
          extern "C" {
            #[cfg_attr(target_arch = "wasm32", link_name = "trace")]
            #[cfg_attr(not(target_arch = "wasm32"), link_name = "wasi:messaging/messaging-types_trace")]
            fn wit_import(
            _: i32, _: i32, );
          }
          wit_import(wit_bindgen::rt::as_i32(e), ptr0);
          let len1 = *((ptr0 + 4) as *const i32) as usize;
          {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr0 + 0) as *const i32) as *mut _, len1, len1))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr0 + 0) as *const i32) as *mut _, len1, len1)).unwrap()}}
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod producer {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      
      pub type Client = super::super::super::wasi::messaging::messaging_types::Client;
      pub type Channel<'a,> = &'a super::super::super::wasi::messaging::messaging_types::Channel;
      pub type Message<'a,> = &'a super::super::super::wasi::messaging::messaging_types::Message;
      pub type Error = super::super::super::wasi::messaging::messaging_types::Error;
      #[allow(clippy::all)]
      pub fn send(c: Client,ch: Channel<'_,>,m: &[Message<'_,>],) -> Result<(),Error>{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          let mut cleanup_list = Vec::new();
          
          #[repr(align(4))]
          struct RetArea([u8; 8]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let vec0 = ch;
          let ptr0 = vec0.as_ptr() as i32;
          let len0 = vec0.len() as i32;
          let vec7 = m;
          let len7 = vec7.len() as i32;
          let layout7 = alloc::Layout::from_size_align_unchecked(vec7.len() * 24, 4);
          let result7 = if layout7.size() != 0
          {
            let ptr = alloc::alloc(layout7);
            if ptr.is_null()
            {
              alloc::handle_alloc_error(layout7);
            }
            ptr
          }else {
            ::core::ptr::null_mut()
          };
          for (i, e) in vec7.into_iter().enumerate() {
            let base = result7 as i32 + (i as i32) * 24;
            {
              let super::super::super::wasi::messaging::messaging_types::Message{ data:data1, format:format1, metadata:metadata1, } = e;
              let vec2 = data1;
              let ptr2 = vec2.as_ptr() as i32;
              let len2 = vec2.len() as i32;
              *((base + 4) as *mut i32) = len2;
              *((base + 0) as *mut i32) = ptr2;
              *((base + 8) as *mut u8) = (match format1 {
                super::super::super::wasi::messaging::messaging_types::FormatSpec::Cloudevents => 0,
                super::super::super::wasi::messaging::messaging_types::FormatSpec::Http => 1,
                super::super::super::wasi::messaging::messaging_types::FormatSpec::Amqp => 2,
                super::super::super::wasi::messaging::messaging_types::FormatSpec::Mqtt => 3,
                super::super::super::wasi::messaging::messaging_types::FormatSpec::Kafka => 4,
                super::super::super::wasi::messaging::messaging_types::FormatSpec::Raw => 5,
              }) as u8;
              match metadata1 {
                Some(e) => {
                  *((base + 12) as *mut u8) = (1i32) as u8;
                  let vec6 = e;
                  let len6 = vec6.len() as i32;
                  let layout6 = alloc::Layout::from_size_align_unchecked(vec6.len() * 16, 4);
                  let result6 = if layout6.size() != 0
                  {
                    let ptr = alloc::alloc(layout6);
                    if ptr.is_null()
                    {
                      alloc::handle_alloc_error(layout6);
                    }
                    ptr
                  }else {
                    ::core::ptr::null_mut()
                  };
                  for (i, e) in vec6.into_iter().enumerate() {
                    let base = result6 as i32 + (i as i32) * 16;
                    {
                      let (t3_0, t3_1, ) = e;
                      let vec4 = t3_0;
                      let ptr4 = vec4.as_ptr() as i32;
                      let len4 = vec4.len() as i32;
                      *((base + 4) as *mut i32) = len4;
                      *((base + 0) as *mut i32) = ptr4;
                      let vec5 = t3_1;
                      let ptr5 = vec5.as_ptr() as i32;
                      let len5 = vec5.len() as i32;
                      *((base + 12) as *mut i32) = len5;
                      *((base + 8) as *mut i32) = ptr5;
                      
                    }}
                    *((base + 20) as *mut i32) = len6;
                    *((base + 16) as *mut i32) = result6 as i32;
                    cleanup_list.extend_from_slice(&[(result6, layout6),]);
                    
                  },
                  None => {
                    {
                      *((base + 12) as *mut u8) = (0i32) as u8;
                      
                    }
                  },
                };
              }}
              let ptr8 = ret_area.as_mut_ptr() as i32;
              #[link(wasm_import_module = "wasi:messaging/producer")]
              extern "C" {
                #[cfg_attr(target_arch = "wasm32", link_name = "send")]
                #[cfg_attr(not(target_arch = "wasm32"), link_name = "wasi:messaging/producer_send")]
                fn wit_import(
                _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
              }
              wit_import(wit_bindgen::rt::as_i32(c), ptr0, len0, result7 as i32, len7, ptr8);
              if layout7.size() != 0 {
                alloc::dealloc(result7, layout7);
              }
              for (ptr, layout) in cleanup_list {
                
                if layout.size() != 0 {
                  
                  alloc::dealloc(ptr, layout);
                  
                }
                
              }
              match i32::from(*((ptr8 + 0) as *const u8)) {
                0 => Ok(()),
                1 => Err(*((ptr8 + 4) as *const i32) as u32),
                #[cfg(not(debug_assertions))]
                _ => ::core::hint::unreachable_unchecked(),
                #[cfg(debug_assertions)]
                _ => panic!("invalid enum discriminant"),
              }
            }
          }
          
        }
        
        
        #[allow(clippy::all)]
        pub mod consumer {
          #[used]
          #[doc(hidden)]
          #[cfg(target_arch = "wasm32")]
          static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
          
          pub type Client = super::super::super::wasi::messaging::messaging_types::Client;
          pub type Message = super::super::super::wasi::messaging::messaging_types::Message;
          pub type Channel<'a,> = &'a super::super::super::wasi::messaging::messaging_types::Channel;
          pub type Error = super::super::super::wasi::messaging::messaging_types::Error;
          pub type GuestConfiguration<'a,> = &'a super::super::super::wasi::messaging::messaging_types::GuestConfiguration;
          #[allow(clippy::all)]
          /// Blocking receive for t-milliseconds with ephemeral subscription – if no message is received, returns None
          pub fn subscribe_try_receive(c: Client,ch: Channel<'_,>,t_milliseconds: u32,) -> Result<Option<wit_bindgen::rt::vec::Vec::<Message>>,Error>{
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            unsafe {
              
              #[repr(align(4))]
              struct RetArea([u8; 16]);
              let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
              let vec0 = ch;
              let ptr0 = vec0.as_ptr() as i32;
              let len0 = vec0.len() as i32;
              let ptr1 = ret_area.as_mut_ptr() as i32;
              #[link(wasm_import_module = "wasi:messaging/consumer")]
              extern "C" {
                #[cfg_attr(target_arch = "wasm32", link_name = "subscribe-try-receive")]
                #[cfg_attr(not(target_arch = "wasm32"), link_name = "wasi:messaging/consumer_subscribe-try-receive")]
                fn wit_import(
                _: i32, _: i32, _: i32, _: i32, _: i32, );
              }
              wit_import(wit_bindgen::rt::as_i32(c), ptr0, len0, wit_bindgen::rt::as_i32(t_milliseconds), ptr1);
              match i32::from(*((ptr1 + 0) as *const u8)) {
                0 => Ok(match i32::from(*((ptr1 + 4) as *const u8)) {
                  0 => None,
                  1 => Some({
                    let base6 = *((ptr1 + 8) as *const i32);
                    let len6 = *((ptr1 + 12) as *const i32);
                    let mut result6 = Vec::with_capacity(len6 as usize);
                    for i in 0..len6 {
                      let base = base6 + i *24;
                      result6.push({
                        let len2 = *((base + 4) as *const i32) as usize;
                        
                        super::super::super::wasi::messaging::messaging_types::Message{data:Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len2, len2), format:{#[cfg(debug_assertions)]{match i32::from(*((base + 8) as *const u8)) {
                          0 => super::super::super::wasi::messaging::messaging_types::FormatSpec::Cloudevents,
                          1 => super::super::super::wasi::messaging::messaging_types::FormatSpec::Http,
                          2 => super::super::super::wasi::messaging::messaging_types::FormatSpec::Amqp,
                          3 => super::super::super::wasi::messaging::messaging_types::FormatSpec::Mqtt,
                          4 => super::super::super::wasi::messaging::messaging_types::FormatSpec::Kafka,
                          5 => super::super::super::wasi::messaging::messaging_types::FormatSpec::Raw,
                          _ => panic!("invalid enum discriminant"),
                        }}#[cfg(not(debug_assertions))]{::core::mem::transmute::<_, super::super::super::wasi::messaging::messaging_types::FormatSpec>(i32::from(*((base + 8) as *const u8)) as u8)}}, metadata:match i32::from(*((base + 12) as *const u8)) {
                          0 => None,
                          1 => Some({
                            let base5 = *((base + 16) as *const i32);
                            let len5 = *((base + 20) as *const i32);
                            let mut result5 = Vec::with_capacity(len5 as usize);
                            for i in 0..len5 {
                              let base = base5 + i *16;
                              result5.push({
                                let len3 = *((base + 4) as *const i32) as usize;
                                let len4 = *((base + 12) as *const i32) as usize;
                                
                                ({#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len3, len3))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len3, len3)).unwrap()}}, {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 8) as *const i32) as *mut _, len4, len4))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 8) as *const i32) as *mut _, len4, len4)).unwrap()}})
                              });
                            }
                            wit_bindgen::rt::dealloc(base5, (len5 as usize) * 16, 4);
                            
                            result5
                          }),
                          #[cfg(not(debug_assertions))]
                          _ => ::core::hint::unreachable_unchecked(),
                          #[cfg(debug_assertions)]
                          _ => panic!("invalid enum discriminant"),
                        }, }
                      });
                    }
                    wit_bindgen::rt::dealloc(base6, (len6 as usize) * 24, 4);
                    
                    result6
                  }),
                  #[cfg(not(debug_assertions))]
                  _ => ::core::hint::unreachable_unchecked(),
                  #[cfg(debug_assertions)]
                  _ => panic!("invalid enum discriminant"),
                }),
                1 => Err(*((ptr1 + 4) as *const i32) as u32),
                #[cfg(not(debug_assertions))]
                _ => ::core::hint::unreachable_unchecked(),
                #[cfg(debug_assertions)]
                _ => panic!("invalid enum discriminant"),
              }
            }
          }
          #[allow(clippy::all)]
          /// Blocking receive until message with ephemeral subscription
          pub fn subscribe_receive(c: Client,ch: Channel<'_,>,) -> Result<wit_bindgen::rt::vec::Vec::<Message>,Error>{
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            unsafe {
              
              #[repr(align(4))]
              struct RetArea([u8; 12]);
              let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
              let vec0 = ch;
              let ptr0 = vec0.as_ptr() as i32;
              let len0 = vec0.len() as i32;
              let ptr1 = ret_area.as_mut_ptr() as i32;
              #[link(wasm_import_module = "wasi:messaging/consumer")]
              extern "C" {
                #[cfg_attr(target_arch = "wasm32", link_name = "subscribe-receive")]
                #[cfg_attr(not(target_arch = "wasm32"), link_name = "wasi:messaging/consumer_subscribe-receive")]
                fn wit_import(
                _: i32, _: i32, _: i32, _: i32, );
              }
              wit_import(wit_bindgen::rt::as_i32(c), ptr0, len0, ptr1);
              match i32::from(*((ptr1 + 0) as *const u8)) {
                0 => Ok({
                  let base6 = *((ptr1 + 4) as *const i32);
                  let len6 = *((ptr1 + 8) as *const i32);
                  let mut result6 = Vec::with_capacity(len6 as usize);
                  for i in 0..len6 {
                    let base = base6 + i *24;
                    result6.push({
                      let len2 = *((base + 4) as *const i32) as usize;
                      
                      super::super::super::wasi::messaging::messaging_types::Message{data:Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len2, len2), format:{#[cfg(debug_assertions)]{match i32::from(*((base + 8) as *const u8)) {
                        0 => super::super::super::wasi::messaging::messaging_types::FormatSpec::Cloudevents,
                        1 => super::super::super::wasi::messaging::messaging_types::FormatSpec::Http,
                        2 => super::super::super::wasi::messaging::messaging_types::FormatSpec::Amqp,
                        3 => super::super::super::wasi::messaging::messaging_types::FormatSpec::Mqtt,
                        4 => super::super::super::wasi::messaging::messaging_types::FormatSpec::Kafka,
                        5 => super::super::super::wasi::messaging::messaging_types::FormatSpec::Raw,
                        _ => panic!("invalid enum discriminant"),
                      }}#[cfg(not(debug_assertions))]{::core::mem::transmute::<_, super::super::super::wasi::messaging::messaging_types::FormatSpec>(i32::from(*((base + 8) as *const u8)) as u8)}}, metadata:match i32::from(*((base + 12) as *const u8)) {
                        0 => None,
                        1 => Some({
                          let base5 = *((base + 16) as *const i32);
                          let len5 = *((base + 20) as *const i32);
                          let mut result5 = Vec::with_capacity(len5 as usize);
                          for i in 0..len5 {
                            let base = base5 + i *16;
                            result5.push({
                              let len3 = *((base + 4) as *const i32) as usize;
                              let len4 = *((base + 12) as *const i32) as usize;
                              
                              ({#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len3, len3))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len3, len3)).unwrap()}}, {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 8) as *const i32) as *mut _, len4, len4))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 8) as *const i32) as *mut _, len4, len4)).unwrap()}})
                            });
                          }
                          wit_bindgen::rt::dealloc(base5, (len5 as usize) * 16, 4);
                          
                          result5
                        }),
                        #[cfg(not(debug_assertions))]
                        _ => ::core::hint::unreachable_unchecked(),
                        #[cfg(debug_assertions)]
                        _ => panic!("invalid enum discriminant"),
                      }, }
                    });
                  }
                  wit_bindgen::rt::dealloc(base6, (len6 as usize) * 24, 4);
                  
                  result6
                }),
                1 => Err(*((ptr1 + 4) as *const i32) as u32),
                #[cfg(not(debug_assertions))]
                _ => ::core::hint::unreachable_unchecked(),
                #[cfg(debug_assertions)]
                _ => panic!("invalid enum discriminant"),
              }
            }
          }
          #[allow(clippy::all)]
          /// 'Fit-all' type function for updating a guest's configuration – this could be useful for:
          /// - unsubscribing from a channel,
          /// - checkpointing,
          /// - etc..
          pub fn update_guest_configuration(gc: GuestConfiguration<'_,>,) -> Result<(),Error>{
            
            #[allow(unused_imports)]
            use wit_bindgen::rt::{alloc, vec::Vec, string::String};
            unsafe {
              let mut cleanup_list = Vec::new();
              
              #[repr(align(4))]
              struct RetArea([u8; 8]);
              let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
              let super::super::super::wasi::messaging::messaging_types::GuestConfiguration{ channels:channels0, extensions:extensions0, } = gc;
              let vec2 = channels0;
              let len2 = vec2.len() as i32;
              let layout2 = alloc::Layout::from_size_align_unchecked(vec2.len() * 8, 4);
              let result2 = if layout2.size() != 0
              {
                let ptr = alloc::alloc(layout2);
                if ptr.is_null()
                {
                  alloc::handle_alloc_error(layout2);
                }
                ptr
              }else {
                ::core::ptr::null_mut()
              };
              for (i, e) in vec2.into_iter().enumerate() {
                let base = result2 as i32 + (i as i32) * 8;
                {
                  let vec1 = e;
                  let ptr1 = vec1.as_ptr() as i32;
                  let len1 = vec1.len() as i32;
                  *((base + 4) as *mut i32) = len1;
                  *((base + 0) as *mut i32) = ptr1;
                  
                }}
                let (result7_0,result7_1,result7_2,) = match extensions0 {
                  Some(e) => {
                    let vec6 = e;
                    let len6 = vec6.len() as i32;
                    let layout6 = alloc::Layout::from_size_align_unchecked(vec6.len() * 16, 4);
                    let result6 = if layout6.size() != 0
                    {
                      let ptr = alloc::alloc(layout6);
                      if ptr.is_null()
                      {
                        alloc::handle_alloc_error(layout6);
                      }
                      ptr
                    }else {
                      ::core::ptr::null_mut()
                    };
                    for (i, e) in vec6.into_iter().enumerate() {
                      let base = result6 as i32 + (i as i32) * 16;
                      {
                        let (t3_0, t3_1, ) = e;
                        let vec4 = t3_0;
                        let ptr4 = vec4.as_ptr() as i32;
                        let len4 = vec4.len() as i32;
                        *((base + 4) as *mut i32) = len4;
                        *((base + 0) as *mut i32) = ptr4;
                        let vec5 = t3_1;
                        let ptr5 = vec5.as_ptr() as i32;
                        let len5 = vec5.len() as i32;
                        *((base + 12) as *mut i32) = len5;
                        *((base + 8) as *mut i32) = ptr5;
                        
                      }}
                      cleanup_list.extend_from_slice(&[(result6, layout6),]);
                      
                      (1i32, result6 as i32, len6)
                    },
                    None => {
                      (0i32, 0i32, 0i32)
                    },
                  };let ptr8 = ret_area.as_mut_ptr() as i32;
                  #[link(wasm_import_module = "wasi:messaging/consumer")]
                  extern "C" {
                    #[cfg_attr(target_arch = "wasm32", link_name = "update-guest-configuration")]
                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "wasi:messaging/consumer_update-guest-configuration")]
                    fn wit_import(
                    _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
                  }
                  wit_import(result2 as i32, len2, result7_0, result7_1, result7_2, ptr8);
                  if layout2.size() != 0 {
                    alloc::dealloc(result2, layout2);
                  }
                  for (ptr, layout) in cleanup_list {
                    
                    if layout.size() != 0 {
                      
                      alloc::dealloc(ptr, layout);
                      
                    }
                    
                  }
                  match i32::from(*((ptr8 + 0) as *const u8)) {
                    0 => Ok(()),
                    1 => Err(*((ptr8 + 4) as *const i32) as u32),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }
                }
              }
              #[allow(clippy::all)]
              /// A message can exist under several statuses:
              /// (1) available: the message is ready to be read,
              /// (2) acquired: the message has been sent to a consumer (but still exists in the queue),
              /// (3) accepted (result of complete-message): the message has been received and ACK-ed by a consumer and can be safely removed from the queue,
              /// (4) rejected (result of abandon-message): the message has been received and NACK-ed by a consumer, at which point it can be:
              /// - deleted,
              /// - sent to a dead-letter queue, or
              /// - kept in the queue for further processing.
              pub fn complete_message(m: &Message,) -> Result<(),Error>{
                
                #[allow(unused_imports)]
                use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                unsafe {
                  let mut cleanup_list = Vec::new();
                  
                  #[repr(align(4))]
                  struct RetArea([u8; 8]);
                  let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                  let super::super::super::wasi::messaging::messaging_types::Message{ data:data0, format:format0, metadata:metadata0, } = m;
                  let vec1 = data0;
                  let ptr1 = vec1.as_ptr() as i32;
                  let len1 = vec1.len() as i32;
                  let (result6_0,result6_1,result6_2,) = match metadata0 {
                    Some(e) => {
                      let vec5 = e;
                      let len5 = vec5.len() as i32;
                      let layout5 = alloc::Layout::from_size_align_unchecked(vec5.len() * 16, 4);
                      let result5 = if layout5.size() != 0
                      {
                        let ptr = alloc::alloc(layout5);
                        if ptr.is_null()
                        {
                          alloc::handle_alloc_error(layout5);
                        }
                        ptr
                      }else {
                        ::core::ptr::null_mut()
                      };
                      for (i, e) in vec5.into_iter().enumerate() {
                        let base = result5 as i32 + (i as i32) * 16;
                        {
                          let (t2_0, t2_1, ) = e;
                          let vec3 = t2_0;
                          let ptr3 = vec3.as_ptr() as i32;
                          let len3 = vec3.len() as i32;
                          *((base + 4) as *mut i32) = len3;
                          *((base + 0) as *mut i32) = ptr3;
                          let vec4 = t2_1;
                          let ptr4 = vec4.as_ptr() as i32;
                          let len4 = vec4.len() as i32;
                          *((base + 12) as *mut i32) = len4;
                          *((base + 8) as *mut i32) = ptr4;
                          
                        }}
                        cleanup_list.extend_from_slice(&[(result5, layout5),]);
                        
                        (1i32, result5 as i32, len5)
                      },
                      None => {
                        (0i32, 0i32, 0i32)
                      },
                    };let ptr7 = ret_area.as_mut_ptr() as i32;
                    #[link(wasm_import_module = "wasi:messaging/consumer")]
                    extern "C" {
                      #[cfg_attr(target_arch = "wasm32", link_name = "complete-message")]
                      #[cfg_attr(not(target_arch = "wasm32"), link_name = "wasi:messaging/consumer_complete-message")]
                      fn wit_import(
                      _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
                    }
                    wit_import(ptr1, len1, match format0 {
                      super::super::super::wasi::messaging::messaging_types::FormatSpec::Cloudevents => 0,
                      super::super::super::wasi::messaging::messaging_types::FormatSpec::Http => 1,
                      super::super::super::wasi::messaging::messaging_types::FormatSpec::Amqp => 2,
                      super::super::super::wasi::messaging::messaging_types::FormatSpec::Mqtt => 3,
                      super::super::super::wasi::messaging::messaging_types::FormatSpec::Kafka => 4,
                      super::super::super::wasi::messaging::messaging_types::FormatSpec::Raw => 5,
                    }, result6_0, result6_1, result6_2, ptr7);
                    for (ptr, layout) in cleanup_list {
                      
                      if layout.size() != 0 {
                        
                        alloc::dealloc(ptr, layout);
                        
                      }
                      
                    }
                    match i32::from(*((ptr7 + 0) as *const u8)) {
                      0 => Ok(()),
                      1 => Err(*((ptr7 + 4) as *const i32) as u32),
                      #[cfg(not(debug_assertions))]
                      _ => ::core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }
                  }
                }
                #[allow(clippy::all)]
                pub fn abandon_message(m: &Message,) -> Result<(),Error>{
                  
                  #[allow(unused_imports)]
                  use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                  unsafe {
                    let mut cleanup_list = Vec::new();
                    
                    #[repr(align(4))]
                    struct RetArea([u8; 8]);
                    let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                    let super::super::super::wasi::messaging::messaging_types::Message{ data:data0, format:format0, metadata:metadata0, } = m;
                    let vec1 = data0;
                    let ptr1 = vec1.as_ptr() as i32;
                    let len1 = vec1.len() as i32;
                    let (result6_0,result6_1,result6_2,) = match metadata0 {
                      Some(e) => {
                        let vec5 = e;
                        let len5 = vec5.len() as i32;
                        let layout5 = alloc::Layout::from_size_align_unchecked(vec5.len() * 16, 4);
                        let result5 = if layout5.size() != 0
                        {
                          let ptr = alloc::alloc(layout5);
                          if ptr.is_null()
                          {
                            alloc::handle_alloc_error(layout5);
                          }
                          ptr
                        }else {
                          ::core::ptr::null_mut()
                        };
                        for (i, e) in vec5.into_iter().enumerate() {
                          let base = result5 as i32 + (i as i32) * 16;
                          {
                            let (t2_0, t2_1, ) = e;
                            let vec3 = t2_0;
                            let ptr3 = vec3.as_ptr() as i32;
                            let len3 = vec3.len() as i32;
                            *((base + 4) as *mut i32) = len3;
                            *((base + 0) as *mut i32) = ptr3;
                            let vec4 = t2_1;
                            let ptr4 = vec4.as_ptr() as i32;
                            let len4 = vec4.len() as i32;
                            *((base + 12) as *mut i32) = len4;
                            *((base + 8) as *mut i32) = ptr4;
                            
                          }}
                          cleanup_list.extend_from_slice(&[(result5, layout5),]);
                          
                          (1i32, result5 as i32, len5)
                        },
                        None => {
                          (0i32, 0i32, 0i32)
                        },
                      };let ptr7 = ret_area.as_mut_ptr() as i32;
                      #[link(wasm_import_module = "wasi:messaging/consumer")]
                      extern "C" {
                        #[cfg_attr(target_arch = "wasm32", link_name = "abandon-message")]
                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "wasi:messaging/consumer_abandon-message")]
                        fn wit_import(
                        _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
                      }
                      wit_import(ptr1, len1, match format0 {
                        super::super::super::wasi::messaging::messaging_types::FormatSpec::Cloudevents => 0,
                        super::super::super::wasi::messaging::messaging_types::FormatSpec::Http => 1,
                        super::super::super::wasi::messaging::messaging_types::FormatSpec::Amqp => 2,
                        super::super::super::wasi::messaging::messaging_types::FormatSpec::Mqtt => 3,
                        super::super::super::wasi::messaging::messaging_types::FormatSpec::Kafka => 4,
                        super::super::super::wasi::messaging::messaging_types::FormatSpec::Raw => 5,
                      }, result6_0, result6_1, result6_2, ptr7);
                      for (ptr, layout) in cleanup_list {
                        
                        if layout.size() != 0 {
                          
                          alloc::dealloc(ptr, layout);
                          
                        }
                        
                      }
                      match i32::from(*((ptr7 + 0) as *const u8)) {
                        0 => Ok(()),
                        1 => Err(*((ptr7 + 4) as *const i32) as u32),
                        #[cfg(not(debug_assertions))]
                        _ => ::core::hint::unreachable_unchecked(),
                        #[cfg(debug_assertions)]
                        _ => panic!("invalid enum discriminant"),
                      }
                    }
                  }
                  
                }
                
              }
            }
            pub mod exports {
              pub mod wasi {
                pub mod messaging {
                  
                  #[allow(clippy::all)]
                  pub mod messaging_guest {
                    #[used]
                    #[doc(hidden)]
                    #[cfg(target_arch = "wasm32")]
                    static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_section;
                    
                    pub type Message = super::super::super::super::wasi::messaging::messaging_types::Message;
                    pub type GuestConfiguration = super::super::super::super::wasi::messaging::messaging_types::GuestConfiguration;
                    pub type Error = super::super::super::super::wasi::messaging::messaging_types::Error;
                    pub trait MessagingGuest {
                      /// Returns the list of channels (and extension metadata within guest-configuration) that
                      /// this component should subscribe to and be handled by the subsequent handler within guest-configuration
                      fn configure() -> Result<GuestConfiguration,Error>;
                      /// Whenever this guest receives a message in one of the subscribed channels, the message is sent to this handler
                      fn handler(ms: wit_bindgen::rt::vec::Vec::<Message>,) -> Result<(),Error>;
                    }
                    
                    #[doc(hidden)]
                    pub unsafe fn call_configure<T: MessagingGuest>() -> i32 {
                      
                      #[allow(unused_imports)]
                      use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                      
                      // Before executing any other code, use this function to run all static
                      // constructors, if they have not yet been run. This is a hack required
                      // to work around wasi-libc ctors calling import functions to initialize
                      // the environment.
                      //
                      // This functionality will be removed once rust 1.69.0 is stable, at which
                      // point wasi-libc will no longer have this behavior.
                      //
                      // See
                      // https://github.com/bytecodealliance/preview2-prototyping/issues/99
                      // for more details.
                      #[cfg(target_arch="wasm32")]
                      wit_bindgen::rt::run_ctors_once();
                      
                      let result0 = T::configure();
                      let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
                      match result0 {
                        Ok(e) => { {
                          *((ptr1 + 0) as *mut u8) = (0i32) as u8;
                          let super::super::super::super::wasi::messaging::messaging_types::GuestConfiguration{ channels:channels2, extensions:extensions2, } = e;
                          let vec4 = channels2;
                          let len4 = vec4.len() as i32;
                          let layout4 = alloc::Layout::from_size_align_unchecked(vec4.len() * 8, 4);
                          let result4 = if layout4.size() != 0
                          {
                            let ptr = alloc::alloc(layout4);
                            if ptr.is_null()
                            {
                              alloc::handle_alloc_error(layout4);
                            }
                            ptr
                          }else {
                            ::core::ptr::null_mut()
                          };
                          for (i, e) in vec4.into_iter().enumerate() {
                            let base = result4 as i32 + (i as i32) * 8;
                            {
                              let vec3 = (e.into_bytes()).into_boxed_slice();
                              let ptr3 = vec3.as_ptr() as i32;
                              let len3 = vec3.len() as i32;
                              ::core::mem::forget(vec3);
                              *((base + 4) as *mut i32) = len3;
                              *((base + 0) as *mut i32) = ptr3;
                              
                            }}
                            *((ptr1 + 8) as *mut i32) = len4;
                            *((ptr1 + 4) as *mut i32) = result4 as i32;
                            match extensions2 {
                              Some(e) => {
                                *((ptr1 + 12) as *mut u8) = (1i32) as u8;
                                let vec8 = e;
                                let len8 = vec8.len() as i32;
                                let layout8 = alloc::Layout::from_size_align_unchecked(vec8.len() * 16, 4);
                                let result8 = if layout8.size() != 0
                                {
                                  let ptr = alloc::alloc(layout8);
                                  if ptr.is_null()
                                  {
                                    alloc::handle_alloc_error(layout8);
                                  }
                                  ptr
                                }else {
                                  ::core::ptr::null_mut()
                                };
                                for (i, e) in vec8.into_iter().enumerate() {
                                  let base = result8 as i32 + (i as i32) * 16;
                                  {
                                    let (t5_0, t5_1, ) = e;
                                    let vec6 = (t5_0.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr() as i32;
                                    let len6 = vec6.len() as i32;
                                    ::core::mem::forget(vec6);
                                    *((base + 4) as *mut i32) = len6;
                                    *((base + 0) as *mut i32) = ptr6;
                                    let vec7 = (t5_1.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr() as i32;
                                    let len7 = vec7.len() as i32;
                                    ::core::mem::forget(vec7);
                                    *((base + 12) as *mut i32) = len7;
                                    *((base + 8) as *mut i32) = ptr7;
                                    
                                  }}
                                  *((ptr1 + 20) as *mut i32) = len8;
                                  *((ptr1 + 16) as *mut i32) = result8 as i32;
                                  
                                },
                                None => {
                                  {
                                    *((ptr1 + 12) as *mut u8) = (0i32) as u8;
                                    
                                  }
                                },
                              };
                            } },
                            Err(e) => { {
                              *((ptr1 + 0) as *mut u8) = (1i32) as u8;
                              *((ptr1 + 4) as *mut i32) = wit_bindgen::rt::as_i32(e);
                              
                            } },
                          };ptr1
                        }
                        
                        #[doc(hidden)]
                        pub unsafe fn post_return_configure<T: MessagingGuest>(arg0: i32,) {
                          match i32::from(*((arg0 + 0) as *const u8)) {
                            0 => {
                              let base0 = *((arg0 + 4) as *const i32);
                              let len0 = *((arg0 + 8) as *const i32);
                              for i in 0..len0 {
                                let base = base0 + i *8;
                                {
                                  wit_bindgen::rt::dealloc(*((base + 0) as *const i32), (*((base + 4) as *const i32)) as usize, 1);
                                  
                                }
                              }
                              wit_bindgen::rt::dealloc(base0, (len0 as usize) * 8, 4);
                              match i32::from(*((arg0 + 12) as *const u8)) {
                                0 => (),
                                _ => {
                                  let base1 = *((arg0 + 16) as *const i32);
                                  let len1 = *((arg0 + 20) as *const i32);
                                  for i in 0..len1 {
                                    let base = base1 + i *16;
                                    {
                                      wit_bindgen::rt::dealloc(*((base + 0) as *const i32), (*((base + 4) as *const i32)) as usize, 1);
                                      wit_bindgen::rt::dealloc(*((base + 8) as *const i32), (*((base + 12) as *const i32)) as usize, 1);
                                      
                                    }
                                  }
                                  wit_bindgen::rt::dealloc(base1, (len1 as usize) * 16, 4);
                                  
                                },
                              }
                              
                            },
                            _ => (),
                          }
                        }
                        
                        #[doc(hidden)]
                        pub unsafe fn call_handler<T: MessagingGuest>(arg0: i32,arg1: i32,) -> i32 {
                          
                          #[allow(unused_imports)]
                          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                          
                          // Before executing any other code, use this function to run all static
                          // constructors, if they have not yet been run. This is a hack required
                          // to work around wasi-libc ctors calling import functions to initialize
                          // the environment.
                          //
                          // This functionality will be removed once rust 1.69.0 is stable, at which
                          // point wasi-libc will no longer have this behavior.
                          //
                          // See
                          // https://github.com/bytecodealliance/preview2-prototyping/issues/99
                          // for more details.
                          #[cfg(target_arch="wasm32")]
                          wit_bindgen::rt::run_ctors_once();
                          
                          let base4 = arg0;
                          let len4 = arg1;
                          let mut result4 = Vec::with_capacity(len4 as usize);
                          for i in 0..len4 {
                            let base = base4 + i *24;
                            result4.push({
                              let len0 = *((base + 4) as *const i32) as usize;
                              
                              super::super::super::super::wasi::messaging::messaging_types::Message{data:Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len0, len0), format:{#[cfg(debug_assertions)]{match i32::from(*((base + 8) as *const u8)) {
                                0 => super::super::super::super::wasi::messaging::messaging_types::FormatSpec::Cloudevents,
                                1 => super::super::super::super::wasi::messaging::messaging_types::FormatSpec::Http,
                                2 => super::super::super::super::wasi::messaging::messaging_types::FormatSpec::Amqp,
                                3 => super::super::super::super::wasi::messaging::messaging_types::FormatSpec::Mqtt,
                                4 => super::super::super::super::wasi::messaging::messaging_types::FormatSpec::Kafka,
                                5 => super::super::super::super::wasi::messaging::messaging_types::FormatSpec::Raw,
                                _ => panic!("invalid enum discriminant"),
                              }}#[cfg(not(debug_assertions))]{::core::mem::transmute::<_, super::super::super::super::wasi::messaging::messaging_types::FormatSpec>(i32::from(*((base + 8) as *const u8)) as u8)}}, metadata:match i32::from(*((base + 12) as *const u8)) {
                                0 => None,
                                1 => Some({
                                  let base3 = *((base + 16) as *const i32);
                                  let len3 = *((base + 20) as *const i32);
                                  let mut result3 = Vec::with_capacity(len3 as usize);
                                  for i in 0..len3 {
                                    let base = base3 + i *16;
                                    result3.push({
                                      let len1 = *((base + 4) as *const i32) as usize;
                                      let len2 = *((base + 12) as *const i32) as usize;
                                      
                                      ({#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len1, len1))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len1, len1)).unwrap()}}, {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 8) as *const i32) as *mut _, len2, len2))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 8) as *const i32) as *mut _, len2, len2)).unwrap()}})
                                    });
                                  }
                                  wit_bindgen::rt::dealloc(base3, (len3 as usize) * 16, 4);
                                  
                                  result3
                                }),
                                #[cfg(not(debug_assertions))]
                                _ => ::core::hint::unreachable_unchecked(),
                                #[cfg(debug_assertions)]
                                _ => panic!("invalid enum discriminant"),
                              }, }
                            });
                          }
                          wit_bindgen::rt::dealloc(base4, (len4 as usize) * 24, 4);
                          let result5 = T::handler(result4);
                          let ptr6 = _RET_AREA.0.as_mut_ptr() as i32;
                          match result5 {
                            Ok(_) => { {
                              *((ptr6 + 0) as *mut u8) = (0i32) as u8;
                              
                            } },
                            Err(e) => { {
                              *((ptr6 + 0) as *mut u8) = (1i32) as u8;
                              *((ptr6 + 4) as *mut i32) = wit_bindgen::rt::as_i32(e);
                              
                            } },
                          };ptr6
                        }
                        
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        
                        #[repr(align(4))]
                        struct _RetArea([u8; 24]);
                        static mut _RET_AREA: _RetArea = _RetArea([0; 24]);
                        
                      }
                      
                    }
                  }
                }
                
                #[cfg(target_arch = "wasm32")]
                #[link_section = "component-type:messaging"]
                #[doc(hidden)]
                pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 2203] = [3, 0, 9, 109, 101, 115, 115, 97, 103, 105, 110, 103, 0, 97, 115, 109, 13, 0, 1, 0, 7, 163, 16, 1, 65, 15, 1, 66, 26, 1, 109, 6, 11, 99, 108, 111, 117, 100, 101, 118, 101, 110, 116, 115, 4, 104, 116, 116, 112, 4, 97, 109, 113, 112, 4, 109, 113, 116, 116, 5, 107, 97, 102, 107, 97, 3, 114, 97, 119, 4, 0, 11, 102, 111, 114, 109, 97, 116, 45, 115, 112, 101, 99, 3, 0, 0, 1, 112, 125, 1, 111, 2, 115, 115, 1, 112, 3, 1, 107, 4, 1, 114, 3, 4, 100, 97, 116, 97, 2, 6, 102, 111, 114, 109, 97, 116, 1, 8, 109, 101, 116, 97, 100, 97, 116, 97, 5, 4, 0, 7, 109, 101, 115, 115, 97, 103, 101, 3, 0, 6, 1, 121, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 8, 1, 121, 4, 0, 6, 99, 108, 105, 101, 110, 116, 3, 0, 10, 1, 115, 4, 0, 7, 99, 104, 97, 110, 110, 101, 108, 3, 0, 12, 1, 112, 13, 1, 114, 2, 8, 99, 104, 97, 110, 110, 101, 108, 115, 14, 10, 101, 120, 116, 101, 110, 115, 105, 111, 110, 115, 5, 4, 0, 19, 103, 117, 101, 115, 116, 45, 99, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 3, 0, 15, 1, 64, 1, 1, 99, 11, 1, 0, 4, 0, 10, 100, 105, 115, 99, 111, 110, 110, 101, 99, 116, 1, 17, 1, 106, 1, 11, 1, 9, 1, 64, 1, 4, 110, 97, 109, 101, 115, 0, 18, 4, 0, 7, 99, 111, 110, 110, 101, 99, 116, 1, 19, 1, 64, 1, 1, 101, 9, 1, 0, 4, 0, 10, 100, 114, 111, 112, 45, 101, 114, 114, 111, 114, 1, 20, 1, 64, 1, 1, 101, 9, 0, 115, 4, 0, 5, 116, 114, 97, 99, 101, 1, 21, 4, 1, 30, 119, 97, 115, 105, 58, 109, 101, 115, 115, 97, 103, 105, 110, 103, 47, 109, 101, 115, 115, 97, 103, 105, 110, 103, 45, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 6, 99, 108, 105, 101, 110, 116, 2, 3, 0, 0, 7, 99, 104, 97, 110, 110, 101, 108, 2, 3, 0, 0, 7, 109, 101, 115, 115, 97, 103, 101, 2, 3, 0, 0, 5, 101, 114, 114, 111, 114, 1, 66, 12, 2, 3, 2, 1, 1, 4, 0, 6, 99, 108, 105, 101, 110, 116, 3, 0, 0, 2, 3, 2, 1, 2, 4, 0, 7, 99, 104, 97, 110, 110, 101, 108, 3, 0, 2, 2, 3, 2, 1, 3, 4, 0, 7, 109, 101, 115, 115, 97, 103, 101, 3, 0, 4, 2, 3, 2, 1, 4, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 6, 1, 112, 5, 1, 106, 0, 1, 7, 1, 64, 3, 1, 99, 1, 2, 99, 104, 3, 1, 109, 8, 0, 9, 4, 0, 4, 115, 101, 110, 100, 1, 10, 4, 1, 23, 119, 97, 115, 105, 58, 109, 101, 115, 115, 97, 103, 105, 110, 103, 47, 112, 114, 111, 100, 117, 99, 101, 114, 5, 5, 2, 3, 0, 0, 19, 103, 117, 101, 115, 116, 45, 99, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 1, 66, 13, 2, 3, 2, 1, 3, 4, 0, 7, 109, 101, 115, 115, 97, 103, 101, 3, 0, 0, 2, 3, 2, 1, 6, 4, 0, 19, 103, 117, 101, 115, 116, 45, 99, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 3, 0, 2, 2, 3, 2, 1, 4, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 4, 1, 106, 1, 3, 1, 5, 1, 64, 0, 0, 6, 4, 0, 9, 99, 111, 110, 102, 105, 103, 117, 114, 101, 1, 7, 1, 112, 1, 1, 106, 0, 1, 5, 1, 64, 1, 2, 109, 115, 8, 0, 9, 4, 0, 7, 104, 97, 110, 100, 108, 101, 114, 1, 10, 4, 1, 30, 119, 97, 115, 105, 58, 109, 101, 115, 115, 97, 103, 105, 110, 103, 47, 109, 101, 115, 115, 97, 103, 105, 110, 103, 45, 103, 117, 101, 115, 116, 5, 7, 1, 66, 24, 2, 3, 2, 1, 1, 4, 0, 6, 99, 108, 105, 101, 110, 116, 3, 0, 0, 2, 3, 2, 1, 3, 4, 0, 7, 109, 101, 115, 115, 97, 103, 101, 3, 0, 2, 2, 3, 2, 1, 2, 4, 0, 7, 99, 104, 97, 110, 110, 101, 108, 3, 0, 4, 2, 3, 2, 1, 4, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 6, 2, 3, 2, 1, 6, 4, 0, 19, 103, 117, 101, 115, 116, 45, 99, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 3, 0, 8, 1, 112, 3, 1, 107, 10, 1, 106, 1, 11, 1, 7, 1, 64, 3, 1, 99, 1, 2, 99, 104, 5, 14, 116, 45, 109, 105, 108, 108, 105, 115, 101, 99, 111, 110, 100, 115, 121, 0, 12, 4, 0, 21, 115, 117, 98, 115, 99, 114, 105, 98, 101, 45, 116, 114, 121, 45, 114, 101, 99, 101, 105, 118, 101, 1, 13, 1, 106, 1, 10, 1, 7, 1, 64, 2, 1, 99, 1, 2, 99, 104, 5, 0, 14, 4, 0, 17, 115, 117, 98, 115, 99, 114, 105, 98, 101, 45, 114, 101, 99, 101, 105, 118, 101, 1, 15, 1, 106, 0, 1, 7, 1, 64, 1, 2, 103, 99, 9, 0, 16, 4, 0, 26, 117, 112, 100, 97, 116, 101, 45, 103, 117, 101, 115, 116, 45, 99, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 1, 17, 1, 64, 1, 1, 109, 3, 0, 16, 4, 0, 16, 99, 111, 109, 112, 108, 101, 116, 101, 45, 109, 101, 115, 115, 97, 103, 101, 1, 18, 4, 0, 15, 97, 98, 97, 110, 100, 111, 110, 45, 109, 101, 115, 115, 97, 103, 101, 1, 18, 4, 1, 23, 119, 97, 115, 105, 58, 109, 101, 115, 115, 97, 103, 105, 110, 103, 47, 99, 111, 110, 115, 117, 109, 101, 114, 5, 8, 1, 65, 13, 1, 66, 26, 1, 109, 6, 11, 99, 108, 111, 117, 100, 101, 118, 101, 110, 116, 115, 4, 104, 116, 116, 112, 4, 97, 109, 113, 112, 4, 109, 113, 116, 116, 5, 107, 97, 102, 107, 97, 3, 114, 97, 119, 4, 0, 11, 102, 111, 114, 109, 97, 116, 45, 115, 112, 101, 99, 3, 0, 0, 1, 112, 125, 1, 111, 2, 115, 115, 1, 112, 3, 1, 107, 4, 1, 114, 3, 4, 100, 97, 116, 97, 2, 6, 102, 111, 114, 109, 97, 116, 1, 8, 109, 101, 116, 97, 100, 97, 116, 97, 5, 4, 0, 7, 109, 101, 115, 115, 97, 103, 101, 3, 0, 6, 1, 121, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 8, 1, 121, 4, 0, 6, 99, 108, 105, 101, 110, 116, 3, 0, 10, 1, 115, 4, 0, 7, 99, 104, 97, 110, 110, 101, 108, 3, 0, 12, 1, 112, 13, 1, 114, 2, 8, 99, 104, 97, 110, 110, 101, 108, 115, 14, 10, 101, 120, 116, 101, 110, 115, 105, 111, 110, 115, 5, 4, 0, 19, 103, 117, 101, 115, 116, 45, 99, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 3, 0, 15, 1, 64, 1, 1, 99, 11, 1, 0, 4, 0, 10, 100, 105, 115, 99, 111, 110, 110, 101, 99, 116, 1, 17, 1, 106, 1, 11, 1, 9, 1, 64, 1, 4, 110, 97, 109, 101, 115, 0, 18, 4, 0, 7, 99, 111, 110, 110, 101, 99, 116, 1, 19, 1, 64, 1, 1, 101, 9, 1, 0, 4, 0, 10, 100, 114, 111, 112, 45, 101, 114, 114, 111, 114, 1, 20, 1, 64, 1, 1, 101, 9, 0, 115, 4, 0, 5, 116, 114, 97, 99, 101, 1, 21, 3, 1, 30, 119, 97, 115, 105, 58, 109, 101, 115, 115, 97, 103, 105, 110, 103, 47, 109, 101, 115, 115, 97, 103, 105, 110, 103, 45, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 6, 99, 108, 105, 101, 110, 116, 2, 3, 0, 0, 7, 99, 104, 97, 110, 110, 101, 108, 2, 3, 0, 0, 7, 109, 101, 115, 115, 97, 103, 101, 2, 3, 0, 0, 5, 101, 114, 114, 111, 114, 1, 66, 12, 2, 3, 2, 1, 1, 4, 0, 6, 99, 108, 105, 101, 110, 116, 3, 0, 0, 2, 3, 2, 1, 2, 4, 0, 7, 99, 104, 97, 110, 110, 101, 108, 3, 0, 2, 2, 3, 2, 1, 3, 4, 0, 7, 109, 101, 115, 115, 97, 103, 101, 3, 0, 4, 2, 3, 2, 1, 4, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 6, 1, 112, 5, 1, 106, 0, 1, 7, 1, 64, 3, 1, 99, 1, 2, 99, 104, 3, 1, 109, 8, 0, 9, 4, 0, 4, 115, 101, 110, 100, 1, 10, 3, 1, 23, 119, 97, 115, 105, 58, 109, 101, 115, 115, 97, 103, 105, 110, 103, 47, 112, 114, 111, 100, 117, 99, 101, 114, 5, 5, 2, 3, 0, 0, 19, 103, 117, 101, 115, 116, 45, 99, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 1, 66, 24, 2, 3, 2, 1, 1, 4, 0, 6, 99, 108, 105, 101, 110, 116, 3, 0, 0, 2, 3, 2, 1, 3, 4, 0, 7, 109, 101, 115, 115, 97, 103, 101, 3, 0, 2, 2, 3, 2, 1, 2, 4, 0, 7, 99, 104, 97, 110, 110, 101, 108, 3, 0, 4, 2, 3, 2, 1, 4, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 6, 2, 3, 2, 1, 6, 4, 0, 19, 103, 117, 101, 115, 116, 45, 99, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 3, 0, 8, 1, 112, 3, 1, 107, 10, 1, 106, 1, 11, 1, 7, 1, 64, 3, 1, 99, 1, 2, 99, 104, 5, 14, 116, 45, 109, 105, 108, 108, 105, 115, 101, 99, 111, 110, 100, 115, 121, 0, 12, 4, 0, 21, 115, 117, 98, 115, 99, 114, 105, 98, 101, 45, 116, 114, 121, 45, 114, 101, 99, 101, 105, 118, 101, 1, 13, 1, 106, 1, 10, 1, 7, 1, 64, 2, 1, 99, 1, 2, 99, 104, 5, 0, 14, 4, 0, 17, 115, 117, 98, 115, 99, 114, 105, 98, 101, 45, 114, 101, 99, 101, 105, 118, 101, 1, 15, 1, 106, 0, 1, 7, 1, 64, 1, 2, 103, 99, 9, 0, 16, 4, 0, 26, 117, 112, 100, 97, 116, 101, 45, 103, 117, 101, 115, 116, 45, 99, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 1, 17, 1, 64, 1, 1, 109, 3, 0, 16, 4, 0, 16, 99, 111, 109, 112, 108, 101, 116, 101, 45, 109, 101, 115, 115, 97, 103, 101, 1, 18, 4, 0, 15, 97, 98, 97, 110, 100, 111, 110, 45, 109, 101, 115, 115, 97, 103, 101, 1, 18, 3, 1, 23, 119, 97, 115, 105, 58, 109, 101, 115, 115, 97, 103, 105, 110, 103, 47, 99, 111, 110, 115, 117, 109, 101, 114, 5, 7, 1, 66, 13, 2, 3, 2, 1, 3, 4, 0, 7, 109, 101, 115, 115, 97, 103, 101, 3, 0, 0, 2, 3, 2, 1, 6, 4, 0, 19, 103, 117, 101, 115, 116, 45, 99, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 3, 0, 2, 2, 3, 2, 1, 4, 4, 0, 5, 101, 114, 114, 111, 114, 3, 0, 4, 1, 106, 1, 3, 1, 5, 1, 64, 0, 0, 6, 4, 0, 9, 99, 111, 110, 102, 105, 103, 117, 114, 101, 1, 7, 1, 112, 1, 1, 106, 0, 1, 5, 1, 64, 1, 2, 109, 115, 8, 0, 9, 4, 0, 7, 104, 97, 110, 100, 108, 101, 114, 1, 10, 4, 1, 30, 119, 97, 115, 105, 58, 109, 101, 115, 115, 97, 103, 105, 110, 103, 47, 109, 101, 115, 115, 97, 103, 105, 110, 103, 45, 103, 117, 101, 115, 116, 5, 8, 4, 1, 24, 119, 97, 115, 105, 58, 109, 101, 115, 115, 97, 103, 105, 110, 103, 47, 109, 101, 115, 115, 97, 103, 105, 110, 103, 4, 9, 0, 69, 9, 112, 114, 111, 100, 117, 99, 101, 114, 115, 1, 12, 112, 114, 111, 99, 101, 115, 115, 101, 100, 45, 98, 121, 2, 13, 119, 105, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 6, 48, 46, 49, 49, 46, 48, 16, 119, 105, 116, 45, 98, 105, 110, 100, 103, 101, 110, 45, 114, 117, 115, 116, 5, 48, 46, 55, 46, 48, 11, 24, 1, 1, 18, 119, 97, 115, 105, 58, 109, 101, 115, 115, 97, 103, 105, 110, 103, 47, 119, 105, 116, 3, 0, 0];
                
                #[inline(never)]
                #[doc(hidden)]
                #[cfg(target_arch = "wasm32")]
                pub fn __link_section() {}
                