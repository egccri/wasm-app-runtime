# Compiler

编译用白话来说就是把一种语言结构翻译成另一种语言结构，每种语言都有自己的结构，最终都会映射到CPU架构上（内存，CPU指令）。而为了方便流程控制，以及使用
CPU和内存，我们发明了几种程序执行模式，堆栈机、寄存器、计数器三种模式。

编译器有两种类型：

+ 解释型
+ 编译型

也有语言将两种过程结合，比如Java和Wasmtime引入运行时编译(JIT)，

大部分编译器有以下过程：

+ 词法分析(lexical analysis)
+ 解析(parsing)或者语法分析(syntax analysis)
+ 语义分析(semantic analysis)
+ 中间代码生成及优化
+ 代码生成(codegen)

扩展：

1. 为什么需要拆分语法分析和语义分析？

语法正确的语义并不一定正确，比如c语言中函数定义void foo(int a){return 0;}。然后这样调用foo("bar")，显然编译不会通过。

语法分析阶段是不会报错的，因为符合语法规范。语义分析阶段会报错，因为违反语义规定(语义分析阶段会进行类型检查)。

但为什么要拆分呢，为什么不直接语义分析？
举例说明，阿拉伯数字和罗马数字，语法不同，但语义相同，可以用同样的语义规则。

------

编译器会在编译期确定类型的大小，真正的内存分配是在运行期，由语言标准库调用操作系统来完成

https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/1rust-dynamic-allocation.html

所有的语言最后都是解释执行的，只不过解释的阶段不一样，也可以说他们的目标语言不同，解释型语言是在虚拟机里解释执行，编译型语言是在CPU上解释执行的

https://zhuanlan.zhihu.com/p/422541443

编译器的三种执行方式

AOT JIT Interpreter

我们说的一个语言的内存模型是指什么？
你可能要问，运行关我编译什么事？其实怎么运行是在编译期确定的，比如类型的内存大小，偏移量等，都在编译期写在代码里，放在可执行内存里。
当然编译器要根据运行内存模型以及运行的平台等运行期信息来编译，同时内存分配也在运行期，所以编译期只能确定一个变量的类型大小，但不知道
它具体的内存地址。

JIT 为什么比 AOT 还要快？


